学习时候,所做的一些笔记。方便之后复习查阅。

## 一. Notes for Algortihms

- [单例模式的七中写法-16/9/9](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer24.md)
- [链表的反转-16/8/13](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer1.md) 
- [二分查找-16/8/14](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer2.md)
- [找出两个有序数组的交集 -16/8/16](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer3.md)
- [在有序的二维数组中的找出指定的数-16/8/17](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer4.md)
- [找出一个字符串中第一个不重复的字符-16/8/17](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer5.md)
- [将字符串中的空格替换成指定字符-16/10/15](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer33.md)
- [用两个栈实现队列-16/8/31](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer15.md)
- [求链表中倒数第 K 个节点-16/8/20](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer6.md)
- [求在数组中连续项和最大的值-16/8/20](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer7.md)
- [求 1+2+...+n 之和-16/8/20](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer8.md)
- [合并两个有序链表形成一个有序链表-16/8/22](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer9.md)
- [判断链表中是否有环-16/8/25](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer10.md)
- [找到链表的中间节点-16/8/25](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer11.md)
- [不用加减乘除做加法[重点位运算]-16/9/1](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer16.md)
- [根据前序和中序遍历重建出二叉树-16/10/14](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer34.md)
- [旋转数组的最小数字[二分查找结合旋转数组的特性]-16/10/17](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer36.md)
- [斐波那契数列-16/9/11](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer27.md)
- [二进制中 1 的个数-16/9/12](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer28.md)
- [数值的整数次方-16/10/16--测试结果有点问题](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer34.md)
- [打印 1 到 n 的中间数-16/10/21--**大数如何表示**](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer37.md)
- [在 o(1) 时间删除链表节点-16/8/26](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer13.md)
- [调整数组顺序使得奇数位于偶数前面[扩展性强]-16/8/29](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer14.md)
- [树的子结构-16/10/23--**代码的鲁棒性**](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer38.md)
- 顺时针打印链表矩阵
- [栈的压入，弹出序列是否相匹配-16/9/1](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer17.md)
- [从上往下打印二叉树[层次遍历]-16/9/4](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer20.md)
- [数组中出现次数超过一半的数字-16/10/22](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer38.md)
- [二叉树的深度[递归解法]-16/9/2](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer18.md)
- 链表中环的入口节点
- [扑克牌的顺子-16/9/27](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer32.md)
- 树中两个节点的最低公共祖先
- [判断是否为平衡二叉树-解法一16/9/3](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer19.md)
- 判断是否为平衡二叉树-解法二
- 机器人运动的范围
- 矩阵中的路径
- 滑动窗口最大值
- 数据流的中位数
- [二叉搜索树的第 k 个节点[测试有问题]-16/9/6](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer22.md)
- [对称的二叉树-16/9/8](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer24.md)
- [删除链表中重复的节点[值得多做几次]-16/9/10](https://github.com/wuchangfeng//BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer26.md)
- 删除链表中重复的节点[无序的情况下-HashSet]
- [字符流中第一个不重复的字符-16/9/24](https://github.com/wuchangfeng//BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer30.md)
- [圆圈中最后剩下的数字(约瑟夫环问题-动态规划问题)-16/9/5](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Algortihms/algorithm-for-offer21.md)
- [寻找和为定值的两个数](http://taop.marchtea.com/02.02.html)

## 二. Notes for Android Heros

* [一个组合控件的诞生](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Android%20Heros/Android-Hero-3.md)
* [ListView 相关解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Android%20Heros/Android-Hero-4.md)
* [ Android 中 Scroll 解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Android%20Heros/Android-Hero-5.md)
* [ Android 动画机制与使用技巧](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Android%20Heros/Android-Hero-5.md)

## 三. Notes for Arts of Android Dev

- [Arts-Development-of-Android-3-1](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-3-1.md)

  本章介绍 View 的基本概念和 View 的滑动相关知识以及关于 View 的事件分发机制实例和源码解析。

- [Arts-Development-of-Android-3-2](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-3-2.md)

  本篇参照郭神 Blog 中的实例，来分析 ViewGroup 的事件分发机制。

- [Arts-Development-of-Android-7-1](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-7-1.md)

  本章介绍 View(视图) 动画相关概念以及应用。

- [Arts-Development-of-Android-10](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-10.md)

  本篇介绍 Handler 和 Message 以及 Looper 的基本用法和工作原理。

- [Arts-Development-of-Android-11-1](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-11-1.md)

  本篇介绍 AsyncTask 的使用方法和工作原理

- [Arts-Development-of-Android-11-2](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-11-2.md)

  本篇介绍 Android 中的线程池 ThreadPoolExecutor 相关概念。

- [Arts-Development-of-Android-11-3](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-11-3.md)

  本篇介绍 HandlerThread 和 IntentService 相关概念。

- [Arts-Development-of-Android-12](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Arts%20of%20Android%20Dev/Arts-Development-of-Android-12.md)

  本章介绍 Bitmap 的加载优化以及 Cache 相关内容。

- Arts-Development-of-Android-1

  本章介绍生命周期和启动模式概念。

- Arts-Development-of-Android-2

  本章介绍 Android 中 IPC 相关概念。

- Arts-Development-of-Android-4

  本章介绍 Remote Views 的相关概念与应用。

- Arts-Development-of-Android-6

  本章深入介绍 Android 中的 Drawable

- Arts-Development-of-Android-9

  本章介绍 Android 中四大组件工作过程。

## 四. Notes for Design Pattern

- [面向接口编程以及策略模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-1.md)

  这一节学习将封装的概念进一步引申，把经常变化的部分抽离出来即封装起来，让经常变化的不会影响到其他部分。进一步理解**针对接口**编程的好处以及组合模式相对于继承所带来的优点。

- [设计模式之观察者模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-2.md)

  观察者模式就像一种订阅的机制，你对什么信息内容感兴趣，而不想错过这些，则可以订阅这些消息，一旦有新的消息发布，你就会接收到最新的消息，当然当你不厌其烦的时候，可以选择取消订阅。


- [设计模式之装饰者模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-3.md)

  这一节谈谈装饰者模式。装饰者模式可以在不修改任意底层代码的情况下，动态的添加新的功能。当然继承也可以做到，但是继承会带来许多问题，其一就是编译时代码的臃肿。装饰者模式提供了比继承更加富有弹性的解决方案。

- [设计模式之工厂模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-4.md)

  * 引入的初衷就是为了简化对象的生成。
  * 工厂方法使用继承，将对象的创建委托给子类，子类实现工厂方法来创建对象。
  * 抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。
  * 为了让我们实现解耦，针对抽象编程。

- [设计模式之单例模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-5.md)

  这一节比较重要的就是要思考为什么需要单利模式以及单利模式的种类。感觉还是涉及到了多线程以及多进程的问题。大家对一个对象操作，必须保证该对象给大家的数据都是一致的。

- [设计模式之命令模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-6.md)

  命令模式感觉还是很好理解的，调用者和被调用者不直接交互。通过命令来交互，解决对象相互之间依赖，实现解耦。如果对这个命令进行持久化，扩充一下有点像消息队列的思想了。

- [设计模式之外观模式和适配器模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-7.md)

  适配器很好理解，电源适配器之类的。注意适配器是将接口包装起来，改变其接口。而外观模式则是将一群对象包装起来，影藏其内部的实现细节。对外提供简化的接口。

- [设计模式之模板方法模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-8.md)

- [设计模式之迭代器模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-9.md)

  提供一种方法，顺序访问一个集合对象中的各个元素，但是又不暴露其内部元素的表示[list 还是 array]。这样让集合的接口接口和实现变得简单，也可以让集合更加专注于管理集合中的元素，而不用花费精力去理会遍历上的事情。


- [设计模式之状态模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-10.md)

  通常性的我们喜欢利用 if... else if... else 或者 switch...case...来进行状态的切换，在状态类型较少或者简单的情况下这样可以达到一些我们想要的目的，但是**一旦状态判断复杂或者增加了新的状态**，这样的判断就显得非常不好了。

  较多情况下**对象往往会根据自身的状态来决定自身表现的行为**，这些**状态都在对象内部定义好了的**。

- [设计模式之代理模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-11.md)

  这里一步一步的思考。首先思考为什么需要代理模式。然后引出动态代理的概念，进行进一步探讨出静态代理的弊端，引出动态代理。以及思考动态代理能够做些什么有什么优势。

- [设计模式之组合模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-12.md)

  不做过多评论，看看对应文章即可。

- [设计模式之建造者模式](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Design%20pattern/Head-first-design-pattern-13.md)

  当设计的类有许多属性的时候，并且这些属性都处于一种可选的状态，用户可以自由定制，那么就可以使用建造者模式。

  这里要思考为什么 Builder 要设计成静态的？使用 static 就如同你新建了一个 JAVA 文件，静态内部类不会保持对外部类的引用。如果你的 Builder 需要外部类的引用，那它 Build 就没有意义了，所以必须加 static。

## 五. Notes for Java Se

* [Java 集合框架](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/Java-se1.md)

* [Java 多线程-重点](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/Java-se2.md)

* [Java 泛型深入](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/Java-se3.md)

* [Java NIO 的学习-未深入](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/Java-se7.md)

* [Java 注解](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/java-annotation.md)

  学习 Java 注解的基本概念应用。继续学习自定义注解以及利用反射获取自定义注解的相关信息。

* [ ArrayList 的源码解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/java-arraylist.md)

  ArrayList 是 List 中比较经常用到的了。和Vector不同，**ArrayList中的操作不是线程安全的**！ArryList 底层基于数组队列，其最大特点即为动态扩容机制。


* [ LinkedList 的源码解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/java-linkedlist.md)

  LinkedList 是List 接口链表的实现。底层基于双向链表实现的方式使得 LinkedList 在插入和删除时更优于ArrayList，而随机访问则比 ArrayList 逊色些。


* [LinkedHashMap 的源码解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/java-linkedhashmap.md)

  * 相对于 HashMap 的**无序**而言，LinkedHashMap 的输出会按照 **一定的顺序**。
  * LinkedHashMap 由于其自身的结构特点，非常适合于决定元素的快速访问与缓存淘汰问题。
  * LinkedHashMap 内部有一个环形双链表在维持元素的顺序,因此其遍历顺序相对 HashMap 来讲较慢。
  * LinkedHashMap 具有同版本 HashMap 的一些特性。如内部基本构造皆为:数组,链表,红黑树。


* [TreeMap 的源码解析](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Java%20se/java-treemap.md)

    TreeMap 也只是粗略的看了一看。其实现了 SortedMap 接口，TreeMap 其实就是一个红黑树结构，每个 key-value 都可以看做是一个节点，节点根据 **key** 进行排序。TreeMap 可以保证所有的 key-value 处于有序状态。


* [ConcurrentHashMap 实现原理](http://wiki.jikexueyuan.com/project/java-collection/concurrenthashmap.html)

  ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。


* [ArrayMap 实现原理](http://yydcdut.com/2016/06/05/arraymap-analyse/)

  ArrayMap 根本不是哈希表，其实就是一个二叉查找树。有两个数组：key 的 hash 值数组，与对象数组的 key 索引对应，该数组用于二分查找；对象数组，存储真正的键值对，偶数索引是 key ，奇数索引是 value。


* [SparseArray 实现原理](http://extremej.itscoder.com/sparsearray_source_analyse/)

  是用来一定程度上替代 `HashMap` 的，`SparseArray`从名字上看就能猜到跟数组有关系，事实上他底层是两条数组，一组存放`key`，一组存放`value`。

* [Java 并发编程](http://wiki.jikexueyuan.com/project/java-concurrency/)

  Java 并发编程还是比较重要的，在这一章我们可以学习到许多并发编程相关的概念。粗略介绍一下：其实并发编程主要涉及的还是 Java 中多线程的知识，如果去深入，我们学习的知识点肯定要包括不限于以下几点：线程的基本概念、线程间的协作、Volatile 和 Synchronized 关键字以及一些并发编程的特性。

* [深入理解 Java 内存模型](http://wiki.jikexueyuan.com/project/java-memory-model/)

  这一节是并发编程的基础，还没怎么认真看。

  ​

## 六. Notes for Linux C

* [进程间通信-利用管道实现双端通信](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-1.md)
* [进程间通信-利用消息队列来实现](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-5.md)
* [进程间通信-利用信号量机制实现](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-6.md)
* [Linux 异步信号处理机制](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-2.md)
* [Linux 进程管理与程序开发](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-3.md)
* [匿名管道和重定向编程](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20Linux%20c/linux-c-4.md)

## 七. Notes for Python

- [Python 抓取落网音乐](https://github.com/wuchangfeng/Crawler/blob/master/ReadMe-Luowang.MD)
- [Python 爬取 One 内容存至 LeanCloud](https://github.com/wuchangfeng/Crawler/blob/master/ReadMe-One.md)
- [Python 爬取 Sujin 内容存至 LeanCloud](https://github.com/wuchangfeng/Crawler/blob/master/ReadMe-Sujin.md)
- [Python 根据关键字从百度图库下载图片](https://github.com/wuchangfeng/Crawler/blob/master/ReadMe-Baidupic.MD)
- [Python 爬取豆瓣图书 Top250](https://github.com/wuchangfeng/Crawler/tree/master/Douban)
- [Python 爬取拉钩职位分布存储至 MongoDB](https://github.com/wuchangfeng/Crawler/blob/master/LaGou/lagouCrawler.py)
- [Python 脚本来卸载 AS 中的 App](https://github.com/wuchangfeng/Uninstall-App-Automatically)
- [Python 脚本简化 MarkDown 写作](https://github.com/wuchangfeng/MarkDownHelper)


## 八. Notes for JVM

* [JVM 内存分区与内存溢出异常](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.md)

  * 运行时数据区域即内存分区
  * 内存溢出尝试


* 内存**溢出**
    * Java 堆溢出
    * 虚拟机栈和本地方法栈溢出
    * 方法区和运行时常量池溢出
    * 本机直接内存溢出
* [Java 中的内存泄漏](https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md)
    * **静态集合类**引起内存泄漏
    * 当集合里面的对象属性被修改后，再调用remove()方法时不起作用
    * 监听器和各种连接
    * 内部类和外部模块的引用
    * **单例模式**持有外部实例的引用
* [垃圾回收算法](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.md)

    * 垃圾回收的概念
    * 如何判断对象为垃圾
    * 垃圾回收算法的实现思想
    * 如何给对象分配内存
* [类加载机制](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md)
    * 类加载时机
    * 类加载过程
    * [类加载机制之双亲委派模型](https://github.com/wuchangfeng/BlogRes/blob/master/Notes%20for%20JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.md)
    * 类加载器
* 类文件结构
* Java 内存模型与线程
* Java 语法糖
    * [泛型与类型擦除](http://wiki.jikexueyuan.com/project/java-vm/syntactic-sugar.html)
    * 自动拆箱与装箱与遍历循环
    * 条件编译

## 九. Links for Open Source Framework

* [EventBus3.0 框架源码解析](https://zhuanlan.zhihu.com/p/20871335)
* Glide 框架源码解析
* Retrofit 框架源码解析
* [ButterKnife 框架源码解析](https://zhuanlan.zhihu.com/p/21628698)
* [开源选型之 Android 三大图片缓存原理、特性对比](http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=400056342&idx=1&sn=894325d70f16a28bfe8d6a4da31ec304&scene=2&srcid=10210byVbMGLHg7vXUJLgHaR&from=timeline&isappinstalled=0#rd)

## 十. Notes for Effective Java

- 创建和销毁对象
- 对于所有对象都通用的方法 
- 类和接口
- 泛型
- 枚举和注解
- 方法
- 通用程序设计
- 并发
- 异常
- 序列化